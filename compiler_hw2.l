/* Definition section */
%{
	#include "y.tab.h"	/* header file generated by bison */
	#include <stdbool.h>

	extern YYSTYPE yylval; //YYSTYPE
	char buf[256];

	/* This macro is used to record code line */
	#define CONCAT { strncat(buf, yytext, BUF_SIZE - strlen(buf) - 1); }
%}

/* Define regular expression label */
digit		[0-9]
letter		[a-zA-Z]
integer     {digit}+
float       {digit}+"."{digit}+
id			{letter}+({letter}|{digit})*

%option yylineno

%x COMMENT STRING_STATE

/* Rules section */
%%

 /* Arithmetic */
"+"     { yylval.string_val = "+"; printf("+"); return ADD; }
"-" 	{ yylval.string_val = "-"; printf("-"); return SUB; }
"*" 	{ yylval.string_val = "*"; printf("*"); return MUL; }
"/" 	{ yylval.string_val = "/"; printf("/"); return DIV; }
"%"     { yylval.string_val = "%"; printf("%"); return MOD; }
"++"    { yylval.string_val = "++"; printf("++"); return INC; }
"--"    { yylval.string_val = "--"; printf("--"); return DEC; }

 /* Relational */
">"		{ yylval.string_val = ">"; printf(">"); return MT; }
"<"		{ yylval.string_val = "<"; printf("<"); return LT; }
">="	{ yylval.string_val = ">="; printf(">="); return MTE; }
"<="	{ yylval.string_val = "<="; printf("<="); return LTE; }
"=="	{ yylval.string_val = "=="; printf("=="); return EQ; }
"!="	{ yylval.string_val = "!="; printf("!="); return NE; }

 /* Assignment */
"="		{ yylval.string_val = "="; printf("="); return ASGN; }
"+="	{ yylval.string_val = "+="; printf("+="); return ADDASGN; }
"-="	{ yylval.string_val = "-="; printf("-="); return SUBASGN; }
"*="	{ yylval.string_val = "*="; printf("*="); return MULASGN; }
"/="	{ yylval.string_val = "/="; printf("/="); return DIVASGN; }
"%="	{ yylval.string_val = "%="; printf("%="); return MODASGN; }

 /* Logical */
"&&"	{ yylval.string_val = "&&"; printf("&&"); return AND; }
"||"	{ yylval.string_val = "||"; printf("||"); return OR; }
"!"		{ yylval.string_val = "!"; printf("!"); return NOT; }

 /* Delimiters */
"("		{ yylval.string_val = "("; printf("("); return LB; }
")"		{ yylval.string_val = ")"; printf(")"); return RB; }
"{"		{ yylval.string_val = "{"; printf("{"); return LCB; }
"}"		{ yylval.string_val = "}"; printf("}"); return RCB; }
"["		{ yylval.string_val = "["; printf("["); return LSB; }
"]"		{ yylval.string_val = "]"; printf("]"); return RSB; }
","		{ yylval.string_val = ","; printf(","); return COMMA; }

 /* Print Keywords */	
"print"		{ printf("print"); return PRINT; }

 /* Condition and Loop Keywords */
"if"		{ printf("if"); return IF; }
"else"		{ printf("else"); return ELSE; }
"for"		{ printf("for"); return FOR; }
"while"		{ printf("while"); return WHILE; }

 /* Declaration Keywords */
"void"		{ printf("void"); return VOID; }
"int"		{ printf("int"); return INT; }
"float"  	{ printf("float"); return FLOAT; }
"string"  	{ printf("string"); return STRING; }
"bool"  	{ printf("bool"); return BOOL; }

 /* boolean Keywords */
"true"      { printf("true"); return TRUE; }
"false"     { printf("false"); return FALSE; }

"return"    { printf("return"); return RET; }

 /* String Constant */
\"				        { BEGIN STRING_STATE; printf("%s", yytext); }
<STRING_STATE>\"		{ BEGIN INITIAL; printf("%s", yytext); }
<STRING_STATE>[^"]*		{ yylval.string_val = yytext; printf("%s", yytext); return S_CONST; }

 /* Number Constant */
{integer}	{ yylval.i_val = atoi(yytext); printf("%s", yytext); return I_CONST; }
{float}	    { yylval.f_val = atof(yytext); printf("%s", yytext); return F_CONST; }

 /* C type Comment */
"/*"				{ BEGIN COMMENT; printf("%s", yytext); return START_COMMENT; }
<COMMENT>[^*\n]+	{ printf("%s", yytext); }
<COMMENT>\n			{ 
						printf("%s", yytext);
						printf("%d: ", yylineno);
					}
<COMMENT>"*"		{ printf("%s", yytext); }
<COMMENT>"*/"		{ 
						BEGIN INITIAL; 
						printf("%s", yytext);
						return END_COMMENT;
					}

 /* C++ type Comment */
\/\/.*	{ printf("%s", yytext); return CPLUS_COMMENT; }

 /* Variable ID */
 {id}       { yylval.string_val = yytext; printf("%s",yytext); return ID; }

 /* others */

[;]         { yylval.string_val = yytext; printf(";"); return SEMICOLON; }
[\n]        { printf("\n%d: ", yylineno); }
[\t]		{ printf("    "); } /* Ignore */
[ ]			{ printf(" "); }
[^ \t\n] 	{ } /* Ignore other charactor sets */
<<EOF>>     { }

%%

int yywrap()
{
    return 1;
}
